// REPLACE COPYRIGHT


#include "K2Nodes/K2Node_SetPropertyByName.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "Statics/MounteaInventorySystemStatics.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#define LOCTEXT_NAMESPACE "K2Node_SetPropertyByName"

const FName UK2Node_SetPropertyByName::TargetPinName(TEXT("Target"));
const FName UK2Node_SetPropertyByName::PropertyNamePinName(TEXT("PropertyName"));
const FName UK2Node_SetPropertyByName::ValuePinName(TEXT("Value"));

UK2Node_SetPropertyByName::UK2Node_SetPropertyByName(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UK2Node_SetPropertyByName::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* nodeSchema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* targetPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(), TargetPinName);
	
	UEdGraphPin* propertyNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, PropertyNamePinName);
	nodeSchema->SetPinAutogeneratedDefaultValueBasedOnType(propertyNamePin);

	UEdGraphPin* valuePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, ValuePinName);
}

FText UK2Node_SetPropertyByName::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("SetPropertyByName_Title", "Set Property by Name");
}

FText UK2Node_SetPropertyByName::GetTooltipText() const
{
	return LOCTEXT("SetPropertyByName_Tooltip", 
		"Sets a property value on a target object by property name using reflection.\n\n"
		"Similar to 'Set Scalar Parameter Value' but works with any UObject property.\n"
		"Supports: Int, Float, Bool, String, Name, and Byte types.\n\n"
		"Returns false if property doesn't exist or type doesn't match.\n\n"
		"Please, keep in mind that this will set the value directly! No setter is called! Use with extreme caution!");
}

FLinearColor UK2Node_SetPropertyByName::GetNodeTitleColor() const
{
	return FLinearColor(0.0f, 0.55f, 0.62f);
}

FSlateIcon UK2Node_SetPropertyByName::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SetPropertyByName.Small");
}

void UK2Node_SetPropertyByName::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

bool UK2Node_SetPropertyByName::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	if (MyPin->PinName == ValuePinName && MyPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
	{
		const UEdGraphSchema_K2* nodeSchema = GetDefault<UEdGraphSchema_K2>();
		
		if (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec ||
			OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			OutReason = LOCTEXT("InvalidConnection", "Cannot connect to exec or wildcard pins").ToString();
			return true;
		}

		bool bSupported = false;
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int64);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Real);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_String);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte);

		if (!bSupported)
		{
			OutReason = LOCTEXT("UnsupportedType", "Only Int, Float, Bool, String, Name, and Byte types are supported").ToString();
			return true;
		}
	}

	return false;
}

void UK2Node_SetPropertyByName::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (Pin->PinName == ValuePinName)
		RefreshPinTypes();
}

void UK2Node_SetPropertyByName::RefreshPinTypes() const
{
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);
	
	if (valuePin->LinkedTo.Num() > 0)
		valuePin->PinType = valuePin->LinkedTo[0]->PinType;
	else
	{
		valuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
		valuePin->PinType.PinSubCategory = NAME_None;
		valuePin->PinType.PinSubCategoryObject = nullptr;
	}

	GetGraph()->NotifyGraphChanged();
}

UFunction* UK2Node_SetPropertyByName::GetTargetFunction(const UEdGraphPin* ValuePin)
{
	const UClass* staticsClass = UMounteaInventorySystemStatics::StaticClass();
	
	if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int || 
		ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int64)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetIntPropertyValue));
	else if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Real)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetFloatPropertyValue));
	else if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetBoolPropertyValue));
	else if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_String)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetStringPropertyValue));
	else if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetNamePropertyValue));
	else if (ValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetBytePropertyValue));

	return nullptr;
}

void UK2Node_SetPropertyByName::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UEdGraphPin* execPin = GetExecPin();
	UEdGraphPin* thenPin = GetThenPin();
	UEdGraphPin* targetPin = FindPinChecked(TargetPinName);
	UEdGraphPin* propertyNamePin = FindPinChecked(PropertyNamePinName);
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);

	if (valuePin->LinkedTo.Num() == 0)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("NoValueConnected", "@@ must have Value pin connected").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UFunction* targetFunction = GetTargetFunction(valuePin);
	if (!targetFunction)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("UnsupportedValueType", "@@ has unsupported value type").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UK2Node_CallFunction* callFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	callFunctionNode->SetFromFunction(targetFunction);
	callFunctionNode->AllocateDefaultPins();

	CompilerContext.MovePinLinksToIntermediate(*execPin, *callFunctionNode->GetExecPin());
	CompilerContext.MovePinLinksToIntermediate(*thenPin, *callFunctionNode->GetThenPin());

	UEdGraphPin* callTargetPin = callFunctionNode->FindPinChecked(TEXT("Target"));
	CompilerContext.MovePinLinksToIntermediate(*targetPin, *callTargetPin);

	UEdGraphPin* callPropertyNamePin = callFunctionNode->FindPinChecked(TEXT("PropertyName"));
	CompilerContext.MovePinLinksToIntermediate(*propertyNamePin, *callPropertyNamePin);

	UEdGraphPin* callValuePin = callFunctionNode->FindPinChecked(TEXT("Value"));
	CompilerContext.MovePinLinksToIntermediate(*valuePin, *callValuePin);

	BreakAllNodeLinks();
}

#if WITH_EDITOR

FText UK2Node_SetPropertyByName::GetToolTipHeading() const
{
	return LOCTEXT("SetPropertyByName_ToolTipHeading", "Mountea Advanced Inventory System");
}

FName UK2Node_SetPropertyByName::GetCornerIcon() const
{
	return TEXT("MAISStyleSet.MounteaLogo");
}

#endif

#undef LOCTEXT_NAMESPACE