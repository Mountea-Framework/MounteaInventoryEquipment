// Copyright (C) 2025 Dominik (Pavlicek) Morse. All rights reserved.
//
// Developed for the Mountea Framework as a free tool. This solution is provided
// for use and sharing without charge. Redistribution is allowed under the following conditions:
//
// - You may use this solution in commercial products, provided the product is not 
//   this solution itself (or unless significant modifications have been made to the solution).
// - You may not resell or redistribute the original, unmodified solution.
//
// For more information, visit: https://mountea.tools

#include "K2Nodes/K2Node_SetPropertyByName.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "Statics/MounteaInventorySystemStatics.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#define LOCTEXT_NAMESPACE "K2Node_SetPropertyByName"

const FName UK2Node_SetPropertyByName::TargetPinName(TEXT("Target"));
const FName UK2Node_SetPropertyByName::PropertyNamePinName(TEXT("PropertyName"));
const FName UK2Node_SetPropertyByName::ValuePinName(TEXT("Value"));
const FName UK2Node_SetPropertyByName::ReturnValuePinName(TEXT("ReturnValue"));

UK2Node_SetPropertyByName::UK2Node_SetPropertyByName(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UK2Node_SetPropertyByName::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* nodeSchema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);
	
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, ReturnValuePinName);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(), TargetPinName);
	
	UEdGraphPin* propertyNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, PropertyNamePinName);
	propertyNamePin->PinToolTip = LOCTEXT("K2Node_SetPropertyByName_PropertyName", 
		"Define property name you want to set values to.\n"
		"If the property does not exist, false will be returned.\n"
		"If the property type does not match, false will be returned.").ToString();
	nodeSchema->SetPinAutogeneratedDefaultValueBasedOnType(propertyNamePin);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, ValuePinName);
}

void UK2Node_SetPropertyByName::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

bool UK2Node_SetPropertyByName::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	if (MyPin->PinName == ValuePinName && MyPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
	{
		if (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec ||
			OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			OutReason = LOCTEXT("InvalidConnection", "Cannot connect to exec or wildcard pins").ToString();
			return true;
		}

		bool bSupported = false;
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Real);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_String);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Object);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_SoftObject);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_SoftClass);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Class);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct);

		if (!bSupported)
		{
			OutReason = LOCTEXT("UnsupportedType", "Unsupported type - cannot connect").ToString();
			return true;
		}
	}

	return false;
}

void UK2Node_SetPropertyByName::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (Pin->PinName == ValuePinName)
		RefreshPinTypes();
}

void UK2Node_SetPropertyByName::RefreshPinTypes() const
{
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);
	
	if (valuePin->LinkedTo.Num() > 0)
	{
		valuePin->PinType = valuePin->LinkedTo[0]->PinType;
		valuePin->PinType.PinSubCategory = valuePin->LinkedTo[0]->PinType.PinSubCategory;
		valuePin->PinType.PinSubCategoryObject = valuePin->LinkedTo[0]->PinType.PinSubCategoryObject;
	}
	else
	{
		valuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
		valuePin->PinType.PinSubCategory = NAME_None;
		valuePin->PinType.PinSubCategoryObject = nullptr;
	}

	GetGraph()->NotifyGraphChanged();
}

UFunction* UK2Node_SetPropertyByName::GetTargetFunction(const UEdGraphPin* ValuePin)
{
	const UClass* staticsClass = UMounteaInventorySystemStatics::StaticClass();
	
	if (!ValuePin)
		return nullptr;
	
	const bool bValidInputs = ValuePin->LinkedTo.Num() > 0;
	if (!bValidInputs)
		return nullptr;
	
	const FEdGraphPinType& effectiveType = GetEffectiveType(ValuePin);

	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Int || 
		effectiveType.PinCategory == UEdGraphSchema_K2::PC_Int64)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetIntPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Real)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetFloatPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetBoolPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_String)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetStringPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Name)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetNamePropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Byte)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetBytePropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Object)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetObjectPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_SoftObject)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetSoftObjectPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_SoftClass)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetSoftClassPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Class)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetClassPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Struct)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetGenericStructPropertyValue));

	return nullptr;
}

void UK2Node_SetPropertyByName::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UEdGraphPin* execPin = GetExecPin();
	UEdGraphPin* thenPin = GetThenPin();
	UEdGraphPin* targetPin = FindPinChecked(TargetPinName);
	UEdGraphPin* propertyNamePin = FindPinChecked(PropertyNamePinName);
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);
	UEdGraphPin* returnValuePin = FindPinChecked(ReturnValuePinName);

	if (valuePin->LinkedTo.Num() == 0)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("NoValueConnected", "@@ must have Value pin connected").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UFunction* targetFunction = GetTargetFunction(valuePin);
	if (!targetFunction)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("UnsupportedValueType", "@@ has unsupported value type").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UK2Node_CallFunction* callFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	callFunctionNode->SetFromFunction(targetFunction);
	callFunctionNode->AllocateDefaultPins();

	CompilerContext.MovePinLinksToIntermediate(*execPin, *callFunctionNode->GetExecPin());
	CompilerContext.MovePinLinksToIntermediate(*thenPin, *callFunctionNode->GetThenPin());

	UEdGraphPin* functionReturnPin = callFunctionNode->GetReturnValuePin();
	CompilerContext.MovePinLinksToIntermediate(*returnValuePin, *functionReturnPin);

	UEdGraphPin* callTargetPin = callFunctionNode->FindPinChecked(TEXT("Target"));
	CompilerContext.MovePinLinksToIntermediate(*targetPin, *callTargetPin);

	UEdGraphPin* callPropertyNamePin = callFunctionNode->FindPinChecked(TEXT("PropertyName"));
	CompilerContext.MovePinLinksToIntermediate(*propertyNamePin, *callPropertyNamePin);

	UEdGraphPin* callValuePin = callFunctionNode->FindPinChecked(TEXT("Value"));
	const FEdGraphPinType& effectiveType = GetEffectiveType(valuePin);
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Struct)
		callValuePin->PinType = effectiveType;
	CompilerContext.MovePinLinksToIntermediate(*valuePin, *callValuePin);

	BreakAllNodeLinks();
}

void UK2Node_SetPropertyByName::PostReconstructNode()
{
	Super::PostReconstructNode();
	RefreshPinTypes();
}

#if WITH_EDITOR

FText UK2Node_SetPropertyByName::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	FText functionName = LOCTEXT("SetPropertyByName_Title", "Set Property by Name");
	
	if(TitleType == ENodeTitleType::FullTitle)
	{
		FText contextString = LOCTEXT("SetPropertyByName_Subtitle", "Source is Advanced Mountea Inventory & Equipment System");
		
		FFormatNamedArguments namedArgs;
		namedArgs.Add(TEXT("FunctionName"), functionName);
		namedArgs.Add(TEXT("ContextString"), contextString);

		if (contextString.IsEmpty())
			return FText::Format(LOCTEXT("SetPropertyByName_Title_Only", "{FunctionName}"), namedArgs);
		
		return FText::Format(LOCTEXT("SetPropertyByName_Title_WithContext", "{FunctionName}\n{ContextString}"), namedArgs);
	}
	return functionName;
}

FText UK2Node_SetPropertyByName::GetTooltipText() const
{
	return LOCTEXT("SetPropertyByName_Tooltip", 
		"Sets a property value on a target object by property name using reflection.\n\n"
		"Similar to 'Set Scalar Parameter Value' but works with any UObject property.\n"
		"Supported Types:\n"
		"- Int & Int64\n"
		"- Float\n"
		"- Bool\n"
		"- String & Name\n"
		"- Byte\n"
		"- Object (with property class validation)\n"
		"- Soft Object (with property class validation)\n"
		"- Class (with property class validation)\n"
		"- Soft Class (with property class validation)\n"
		"- ANY UStruct (FVector, FGuid, custom structs, etc.)\n"
		"\n"
		"Returns false if property doesn't exist or type doesn't match.\n\n"
		"⚠ Please, keep in mind that this will set the value directly! No setter is called! Use with extreme caution!");
}

FLinearColor UK2Node_SetPropertyByName::GetNodeTitleColor() const
{
	return FLinearColor(0.0f, 0.55f, 0.62f);
}

FSlateIcon UK2Node_SetPropertyByName::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SetPropertyByName.Small");
}

FText UK2Node_SetPropertyByName::GetVisualWarningTooltipText() const
{
	return LOCTEXT("SetPropertyByName_Warning", 
		"⚠ Please, keep in mind that this will set the value directly!\nNo setter is called!\n\nUse with extreme caution!");
}

FText UK2Node_SetPropertyByName::GetToolTipHeading() const
{
	return LOCTEXT("SetPropertyByName_ToolTipHeading", "Mountea Advanced Inventory System");
}

FName UK2Node_SetPropertyByName::GetCornerIcon() const
{
	return TEXT("MAISStyleSet.MounteaLogo");
}

#endif

#undef LOCTEXT_NAMESPACE