// Copyright (C) 2025 Dominik (Pavlicek) Morse. All rights reserved.
//
// Developed for the Mountea Framework as a free tool. This solution is provided
// for use and sharing without charge. Redistribution is allowed under the following conditions:
//
// - You may use this solution in commercial products, provided the product is not 
//   this solution itself (or unless significant modifications have been made to the solution).
// - You may not resell or redistribute the original, unmodified solution.
//
// For more information, visit: https://mountea.tools


#include "K2Nodes/K2Node_SwitchWidgetCommand.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "Kismet/KismetStringLibrary.h"
#include "Settings/MounteaAdvancedInventorySettings.h"
#include "Settings/MounteaAdvancedInventoryUIConfig.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#define LOCTEXT_NAMESPACE "K2Node_SwitchWidgetCommand"

UK2Node_SwitchWidgetCommand::UK2Node_SwitchWidgetCommand(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bCanRenameNode = false;
	bHasDefaultPin = false;
	bIsCaseSensitive = false;
	SetupCaseSensitivityFunction();
	FunctionClass = UKismetStringLibrary::StaticClass();
}

void UK2Node_SwitchWidgetCommand::SetupCaseSensitivityFunction()
{
	FunctionName = (bIsCaseSensitive == true)
		? TEXT("NotEqual_StrStr")
		: TEXT("NotEqual_StriStri");
}

void UK2Node_SwitchWidgetCommand::CreateSelectionPin()
{
	UEdGraphPin* pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, TEXT("Selection"));
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(pin);
}

FEdGraphPinType UK2Node_SwitchWidgetCommand::GetPinType() const 
{ 
	FEdGraphPinType pinType;
	pinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return pinType;
}

FName UK2Node_SwitchWidgetCommand::GetPinNameGivenIndex(const int32 Index) const
{
	check(Index);
	
	TArray<FName> bisiblePins;
	GetVisiblePinNames(bisiblePins);
	
	return bisiblePins[Index];
}

void UK2Node_SwitchWidgetCommand::CreateCasePins()
{
	TArray<FName> predefinedCommands;
	GetWidgetCommandsFromSettings(predefinedCommands);
	
	for (const FName& commandName : predefinedCommands)
	{
		if (!PinNames.Contains(commandName))
			PinNames.Add(commandName, false);
	}
	
	for (const TPair<FName, bool>& pinPair : PinNames)
	{
		if (pinPair.Value)
		{
			UEdGraphPin* newPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, pinPair.Key);
			newPin->bAllowFriendlyName = false;
		}
	}
}

FName UK2Node_SwitchWidgetCommand::GetUniquePinName()
{
	FName newPinName;
	int32 pinIndex = 0;
	while (true)
	{
		newPinName = *FString::Printf(TEXT("Case_%d"), pinIndex++);
		if (!FindPin(newPinName))
			break;
	}
	return newPinName;
}

void UK2Node_SwitchWidgetCommand::AddPinToSwitchNode()
{
	const FName pinName = GetUniquePinName();
	PinNames.Add(pinName, false);

	UEdGraphPin* uniquePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, pinName);
	uniquePin->bAllowFriendlyName = false;
}

void UK2Node_SwitchWidgetCommand::RemovePin(UEdGraphPin* TargetPin)
{
	checkSlow(TargetPin);

	if (IsPredefinedPin(TargetPin->PinName))
	return;

	PinNames.Remove(TargetPin->PinName);
}

void UK2Node_SwitchWidgetCommand::GetWidgetCommandsFromSettings(TArray<FName>& OutCommands)
{
	OutCommands.Empty();
	
	const auto settings = GetDefault<UMounteaAdvancedInventorySettings>();
	if (!settings) return;
	
	const UMounteaAdvancedInventoryUIConfig* uiConfig = settings->InventoryUISettingsConfig.LoadSynchronous();
	if (!uiConfig)
	return;

	TArray<FString> widgetCommands = uiConfig->WidgetCommands.Array();
	widgetCommands.Sort();
	
	for (const FString& Command : widgetCommands)
	{
		OutCommands.Add(FName(*Command));
	}
}

bool UK2Node_SwitchWidgetCommand::IsPredefinedPin(const FName& PinName)
{
	TArray<FName> predefinedCommands;
	GetWidgetCommandsFromSettings(predefinedCommands);
	
	return predefinedCommands.Contains(PinName);
}

void UK2Node_SwitchWidgetCommand::GetVisiblePinNames(TArray<FName>& OutVisiblePins) const
{
	OutVisiblePins.Empty();
	
	for (const TPair<FName, bool>& pinPair : PinNames)
	{
		if (pinPair.Value)
			OutVisiblePins.Add(pinPair.Key);
	}
}

#if WITH_EDITOR

void UK2Node_SwitchWidgetCommand::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	bool bIsDirty = false;
	FName propertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
	if (propertyName == TEXT("PinNames"))
		bIsDirty = true;
	else if (propertyName == TEXT("bIsCaseSensitive"))
	{
		SetupCaseSensitivityFunction();
		FunctionClass = UKismetStringLibrary::StaticClass();
		bIsDirty = true;
	}
	 
	if (bIsDirty)
		ReconstructNode();
	Super::PostEditChangeProperty(PropertyChangedEvent);
	GetGraph()->NotifyNodeChanged(this);
}

FText UK2Node_SwitchWidgetCommand::GetToolTipHeading() const
{
	return LOCTEXT("SwitchWidgetCommand_ToolTipHeading", "Mountea Advanced Inventory System");
}

FText UK2Node_SwitchWidgetCommand::GetTooltipText() const
{
	return LOCTEXT("SwitchWidgetCommand_ToolTip", "Selects an output based on Widget Command from Project Settings");
}

FText UK2Node_SwitchWidgetCommand::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("Switch_WidgetCommand", "Switch on Widget Command");
}

void UK2Node_SwitchWidgetCommand::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
	Super::ValidateNodeDuringCompilation(MessageLog);
	
	TArray<FName> visiblePins;
	GetVisiblePinNames(visiblePins);
	
	TArray<FString> uniquePinNames;
	uniquePinNames.Reserve(visiblePins.Num());
	ESearchCase::Type caseSensitivity = bIsCaseSensitive ? ESearchCase::CaseSensitive : ESearchCase::IgnoreCase;

	for (FName visiblePin : visiblePins)
	{
		FString pinNameString = visiblePin.ToString();

		for (const FString& uniquePin : uniquePinNames)
		{
			if (pinNameString.Equals(uniquePin, caseSensitivity))
			{
				MessageLog.Error(*LOCTEXT("SwitchWidgetCommand_DuplicateCases", "@@ contains duplicate cases.").ToString(), this);
				return;
			}
		}
		uniquePinNames.Emplace(MoveTemp(pinNameString));
	}
}

void UK2Node_SwitchWidgetCommand::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

FLinearColor UK2Node_SwitchWidgetCommand::GetNodeTitleColor() const
{
	return FLinearColor::White;
}

FName UK2Node_SwitchWidgetCommand::GetCornerIcon() const
{
	auto superName = Super::GetCornerIcon();

	if (superName == NAME_None)
		return TEXT("MAISStyleSet.MounteaLogo");

	return superName;
}

FSlateIcon UK2Node_SwitchWidgetCommand::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SwitchIcon.small");
}

#endif

#undef LOCTEXT_NAMESPACE
