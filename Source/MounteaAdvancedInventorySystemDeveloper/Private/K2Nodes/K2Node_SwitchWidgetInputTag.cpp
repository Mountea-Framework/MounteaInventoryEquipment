// Copyright (C) 2025 Dominik (Pavlicek) Morse. All rights reserved.
//
// Developed for the Mountea Framework as a free tool. This solution is provided
// for use and sharing without charge. Redistribution is allowed under the following conditions:
//
// - You may use this solution in commercial products, provided the product is not 
//   this solution itself (or unless significant modifications have been made to the solution).
// - You may not resell or redistribute the original, unmodified solution.
//
// For more information, visit: https://mountea.tools

#include "K2Nodes/K2Node_SwitchWidgetInputTag.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "BlueprintGameplayTagLibrary.h"
#include "Definitions/MounteaInventoryBaseUIDataTypes.h"
#include "Settings/MounteaAdvancedInventorySettings.h"
#include "Settings/MounteaAdvancedInventoryUIConfig.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#define LOCTEXT_NAMESPACE "K2Node_SwitchWidgetInputTag"

UK2Node_SwitchWidgetInputTag::UK2Node_SwitchWidgetInputTag(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bCanRenameNode = false;
	bHasDefaultPin = false;
	FunctionName = TEXT("NotEqual_TagTag");
	FunctionClass = UBlueprintGameplayTagLibrary::StaticClass();
}

void UK2Node_SwitchWidgetInputTag::CreateSelectionPin()
{
	UEdGraphPin* pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, TEXT("Selection"));
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(pin);
}

FEdGraphPinType UK2Node_SwitchWidgetInputTag::GetPinType() const
{
	FEdGraphPinType pinType;
	pinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	pinType.PinSubCategoryObject = FGameplayTag::StaticStruct();
	return pinType;
}

FEdGraphPinType UK2Node_SwitchWidgetInputTag::GetInnerCaseType() const
{
	FEdGraphPinType pinType;
	pinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return pinType;
}

FName UK2Node_SwitchWidgetInputTag::GetPinNameGivenIndex(const int32 Index) const
{
	check(Index);
	return PinNames[Index];
}

void UK2Node_SwitchWidgetInputTag::CreateCasePins()
{
	while (PinTags.Num() > PinNames.Num())
	{
		const FName pinName = GetUniquePinName();
		PinNames.Add(pinName);
	}

	if (PinNames.Num() > PinTags.Num())
		PinNames.SetNum(PinTags.Num());

	for (int32 index = 0; index < PinTags.Num(); ++index)
	{
		if (PinTags[index].IsValid())
			PinNames[index] = PinTags[index].GetTagName();
		else
			PinNames[index] = GetUniquePinName();

		CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[index]);
	}
}

FName UK2Node_SwitchWidgetInputTag::GetUniquePinName()
{
	FName newPinName;
	int32 index = 0;
	while (true)
	{
		newPinName = *FString::Printf(TEXT("Case_%d"), index++);
		if (!FindPin(newPinName))
			break;
	}
	return newPinName;
}

void UK2Node_SwitchWidgetInputTag::AddPinToSwitchNode()
{
	FName pinname = GetUniquePinName();
	PinNames.Add(pinname);

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, pinname);
	if (PinTags.Num() < PinNames.Num())
		PinTags.Add(FGameplayTag());
}

void UK2Node_SwitchWidgetInputTag::RemovePin(UEdGraphPin* TargetPin)
{
	checkSlow(TargetPin);

	FName pinName = TargetPin->PinName;
	int32 index = PinNames.IndexOfByKey(pinName);
	if (index >= 0)
	{
		if (index < PinTags.Num())
			PinTags.RemoveAt(index);
		PinNames.RemoveAt(index);
	}
}

#if WITH_EDITOR

void UK2Node_SwitchWidgetInputTag::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	bool bIsDirty = false;
	const FName propertyName = (PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None);
	if (propertyName == GET_MEMBER_NAME_CHECKED(UK2Node_SwitchWidgetInputTag, PinTags))
	{
		TArray<FGameplayTag> validatedTags;
		for (const FGameplayTag& pinTag : PinTags)
		{
			if (IsValidUIActionTag(pinTag))
				validatedTags.Add(pinTag);
		}
		
		if (validatedTags.Num() != PinTags.Num())
			PinTags = validatedTags;
		
		bIsDirty = true;
	}

	if (bIsDirty)
		ReconstructNode();
	
	Super::PostEditChangeProperty(PropertyChangedEvent);
	GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchWidgetInputTag::GetAvailableUIActionTags(TArray<FGameplayTag>& OutTags)
{
	OutTags.Empty();
	
	const auto inventorySettings = GetDefault<UMounteaAdvancedInventorySettings>();
	if (!inventorySettings) return;
	
	const UMounteaAdvancedInventoryUIConfig* uiConfig = inventorySettings->InventoryUISettingsConfig.LoadSynchronous();
	if (!uiConfig) return;

	for (const FMounteaWidgetInputActionMapping& inputMapping : uiConfig->UIActionMappings)
	{
		if (inputMapping.ActionTag.IsValid())
			OutTags.AddUnique(inputMapping.ActionTag);
	}
}

bool UK2Node_SwitchWidgetInputTag::IsValidUIActionTag(const FGameplayTag& Tag)
{
	if (!Tag.IsValid())
		return false;

	TArray<FGameplayTag> availableTags;
	GetAvailableUIActionTags(availableTags);
	
	return availableTags.Contains(Tag);
}

FText UK2Node_SwitchWidgetInputTag::GetToolTipHeading() const
{
	return LOCTEXT("SwitchWidgetInputTag_ToolTipHeading", "Mountea Advanced Inventory System");
}

FText UK2Node_SwitchWidgetInputTag::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("Switch_WidgetInputTag", "Switch on Widget Input Tag");
}

FText UK2Node_SwitchWidgetInputTag::GetTooltipText() const
{
	return LOCTEXT("SwitchWidgetInputTag_ToolTip", "Selects an output based on Widget Input Tag from Project Settings");
}

void UK2Node_SwitchWidgetInputTag::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

FLinearColor UK2Node_SwitchWidgetInputTag::GetNodeTitleColor() const
{
	return FLinearColor::White;
}

FName UK2Node_SwitchWidgetInputTag::GetCornerIcon() const
{
	auto superName = Super::GetCornerIcon();

	if (superName == NAME_None)
		return TEXT("MAISStyleSet.MounteaLogo");

	return superName;
}

FSlateIcon UK2Node_SwitchWidgetInputTag::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SwitchIcon.small");
}

#endif

#undef LOCTEXT_NAMESPACE