// Copyright (C) 2025 Dominik (Pavlicek) Morse. All rights reserved.
//
// Developed for the Mountea Framework as a free tool. This solution is provided
// for use and sharing without charge. Redistribution is allowed under the following conditions:
//
// - You may use this solution in commercial products, provided the product is not 
//   this solution itself (or unless significant modifications have been made to the solution).
// - You may not resell or redistribute the original, unmodified solution.
//
// For more information, visit: https://mountea.tools

#include "K2Nodes/K2Node_SwitchWidgetInputTag.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "BlueprintGameplayTagLibrary.h"
#include "Definitions/MounteaInventoryBaseUIDataTypes.h"
#include "Settings/MounteaAdvancedInventorySettings.h"
#include "Settings/MounteaAdvancedInventoryUIConfig.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#if WITH_EDITOR
#include "GameplayTagsManager.h"
#endif

#define LOCTEXT_NAMESPACE "K2Node_SwitchWidgetInputTag"

UK2Node_SwitchWidgetInputTag::UK2Node_SwitchWidgetInputTag(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bCanRenameNode = false;
	bHasDefaultPin = false;
	FunctionName = TEXT("NotEqual_TagTag");
	FunctionClass = UBlueprintGameplayTagLibrary::StaticClass();
}

void UK2Node_SwitchWidgetInputTag::CreateSelectionPin()
{
	UEdGraphPin* pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, FGameplayTag::StaticStruct(), TEXT("Selection"));
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(pin);
}

FEdGraphPinType UK2Node_SwitchWidgetInputTag::GetPinType() const
{
	FEdGraphPinType pinType;
	pinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	pinType.PinSubCategoryObject = FGameplayTag::StaticStruct();
	return pinType;
}

FEdGraphPinType UK2Node_SwitchWidgetInputTag::GetInnerCaseType() const
{
	FEdGraphPinType pinType;
	pinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return pinType;
}

FName UK2Node_SwitchWidgetInputTag::GetPinNameGivenIndex(const int32 Index) const
{
	check(Index);
	
	TArray<FName> visiblePins;
	GetVisiblePinNames(visiblePins);
	
	return visiblePins[Index];
}

void UK2Node_SwitchWidgetInputTag::CreateCasePins()
{
	TArray<FGameplayTag> predefinedTags;
	GetAvailableUIActionTags(predefinedTags);
	
	for (const FGameplayTag& predefinedTag : predefinedTags)
	{
		if (!PinTags.Contains(predefinedTag))
			PinTags.Add(predefinedTag, false);
	}
	
	for (const TPair<FGameplayTag, bool>& pinPair : PinTags)
	{
		if (pinPair.Value)
		{
			UEdGraphPin* newPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, pinPair.Key.GetTagName());
			newPin->bAllowFriendlyName = false;
#if WITH_EDITOR
			newPin->PinToolTip = GetTagComment(pinPair.Key);
#endif
		}
	}
}

FName UK2Node_SwitchWidgetInputTag::GetUniquePinName()
{
	FName newPinName;
	int32 index = 0;
	while (true)
	{
		newPinName = *FString::Printf(TEXT("Case_%d"), index++);
		if (!FindPin(newPinName))
			break;
	}
	return newPinName;
}

void UK2Node_SwitchWidgetInputTag::AddPinToSwitchNode()
{
	const FName pinName = GetUniquePinName();
	PinTags.Add(FGameplayTag::RequestGameplayTag(pinName), false);

	UEdGraphPin* uniquePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, pinName);
	uniquePin->bAllowFriendlyName = false;
}

void UK2Node_SwitchWidgetInputTag::RemovePin(UEdGraphPin* TargetPin)
{
	checkSlow(TargetPin);

	if (IsPredefinedPin(TargetPin->PinName))
		return;

	for (auto It = PinTags.CreateIterator(); It; ++It)
	{
		if (It->Key.GetTagName() == TargetPin->PinName)
		{
			It.RemoveCurrent();
			break;
		}
	}
}

void UK2Node_SwitchWidgetInputTag::GetVisiblePinNames(TArray<FName>& OutVisiblePins) const
{
	OutVisiblePins.Empty();
	
	for (const TPair<FGameplayTag, bool>& pinPair : PinTags)
	{
		if (pinPair.Value)
			OutVisiblePins.Add(pinPair.Key.GetTagName());
	}
}

#if WITH_EDITOR

void UK2Node_SwitchWidgetInputTag::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	bool bIsDirty = false;
	const FName propertyName = (PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None);
	if (propertyName == GET_MEMBER_NAME_CHECKED(UK2Node_SwitchWidgetInputTag, PinTags))
		bIsDirty = true;

	if (bIsDirty)
		ReconstructNode();
	
	Super::PostEditChangeProperty(PropertyChangedEvent);
	GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchWidgetInputTag::GetAvailableUIActionTags(TArray<FGameplayTag>& OutTags)
{
	OutTags.Empty();
	
	const auto inventorySettings = GetDefault<UMounteaAdvancedInventorySettings>();
	if (!inventorySettings) return;
	
	const UMounteaAdvancedInventoryUIConfig* uiConfig = inventorySettings->InventoryUISettingsConfig.LoadSynchronous();
	if (!uiConfig) return;

	for (const FMounteaWidgetInputActionMapping& inputMapping : uiConfig->UIActionMappings)
	{
		if (inputMapping.ActionTag.IsValid())
			OutTags.AddUnique(inputMapping.ActionTag);
	}
}

bool UK2Node_SwitchWidgetInputTag::IsPredefinedPin(const FName& PinName)
{
	TArray<FGameplayTag> predefinedTags;
	GetAvailableUIActionTags(predefinedTags);
	
	for (const FGameplayTag& tag : predefinedTags)
	{
		if (tag.GetTagName() == PinName)
			return true;
	}
	
	return false;
}

FText UK2Node_SwitchWidgetInputTag::GetToolTipHeading() const
{
	return LOCTEXT("SwitchWidgetInputTag_ToolTipHeading", "Mountea Advanced Inventory System");
}

FText UK2Node_SwitchWidgetInputTag::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("Switch_WidgetInputTag", "Switch on Widget Input Tag");
}

FText UK2Node_SwitchWidgetInputTag::GetTooltipText() const
{
	return LOCTEXT("SwitchWidgetInputTag_ToolTip", "Selects an output based on Widget Input Tag from Project Settings");
}

void UK2Node_SwitchWidgetInputTag::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

FLinearColor UK2Node_SwitchWidgetInputTag::GetNodeTitleColor() const
{
	return FLinearColor::White;
}

FName UK2Node_SwitchWidgetInputTag::GetCornerIcon() const
{
	auto superName = Super::GetCornerIcon();

	if (superName == NAME_None)
		return TEXT("MAISStyleSet.MounteaLogo");

	return superName;
}

FSlateIcon UK2Node_SwitchWidgetInputTag::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SwitchIcon.small");
}

FString UK2Node_SwitchWidgetInputTag::GetTagComment(const FGameplayTag& Tag)
{
	UGameplayTagsManager& tagsManager = UGameplayTagsManager::Get();
	if (tagsManager.FindTagNode(Tag).Get())
		return tagsManager.FindTagNode(Tag).Get()->GetDevComment();
	return TEXT("");
}

#endif

#undef LOCTEXT_NAMESPACE