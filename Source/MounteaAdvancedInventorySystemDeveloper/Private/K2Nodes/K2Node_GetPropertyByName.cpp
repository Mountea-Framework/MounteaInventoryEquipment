// Copyright (C) 2025 Dominik (Pavlicek) Morse. All rights reserved.
//
// Developed for the Mountea Framework as a free tool. This solution is provided
// for use and sharing without charge. Redistribution is allowed under the following conditions:
//
// - You may use this solution in commercial products, provided the product is not 
//   this solution itself (or unless significant modifications have been made to the solution).
// - You may not resell or redistribute the original, unmodified solution.
//
// For more information, visit: https://mountea.tools

#include "K2Nodes/K2Node_GetPropertyByName.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "Statics/MounteaInventorySystemStatics.h"
#include "Styling/MounteaAdvancedInventoryDeveloperStyle.h"

#define LOCTEXT_NAMESPACE "K2Node_GetPropertyByName"

const FName UK2Node_GetPropertyByName::TargetPinName(TEXT("Target"));
const FName UK2Node_GetPropertyByName::PropertyNamePinName(TEXT("PropertyName"));
const FName UK2Node_GetPropertyByName::ValuePinName(TEXT("Value"));
const FName UK2Node_GetPropertyByName::ReturnValuePinName(TEXT("ReturnValue"));

UK2Node_GetPropertyByName::UK2Node_GetPropertyByName(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UK2Node_GetPropertyByName::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* nodeSchema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, ReturnValuePinName);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(), TargetPinName);

	UEdGraphPin* propertyNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, PropertyNamePinName);
	propertyNamePin->PinToolTip = LOCTEXT("K2Node_GetPropertyByName_PropertyName", 
		"Define property name you want to read values from.\n"
		"If the property does not exist, false will be returned.\n"
		"For Object/SoftObject and Class/SoftClass output cast will be required.").ToString();
	
	nodeSchema->SetPinAutogeneratedDefaultValueBasedOnType(propertyNamePin);

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, ValuePinName);
}

void UK2Node_GetPropertyByName::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	const UClass* actionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(actionKey))
	{
		UBlueprintNodeSpawner* nodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(nodeSpawner != nullptr);
		ActionRegistrar.AddBlueprintAction(actionKey, nodeSpawner);
	}
}

bool UK2Node_GetPropertyByName::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	if (MyPin->PinName == ValuePinName && MyPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
	{
		if (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec ||
			OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			OutReason = LOCTEXT("InvalidConnection", "Cannot connect to exec or wildcard pins").ToString();
			return true;
		}

		bool bSupported = false;
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Real);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_String);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Object);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_SoftObject);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_SoftClass);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Class);
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct && 
					   OtherPin->PinType.PinSubCategoryObject == TBaseStructure<FVector>::Get());
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct && 
					   OtherPin->PinType.PinSubCategoryObject == TBaseStructure<FVector2D>::Get());
		bSupported |= (OtherPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct && 
					   OtherPin->PinType.PinSubCategoryObject == TBaseStructure<FGuid>::Get());

		if (!bSupported)
		{
			OutReason = LOCTEXT("UnsupportedType", "Only Int, Int64, Float, Bool, String, Name, and Byte types are supported").ToString();
			return true;
		}
	}

	return false;
}

void UK2Node_GetPropertyByName::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (Pin->PinName == ValuePinName)
		RefreshPinTypes();
}

void UK2Node_GetPropertyByName::RefreshPinTypes() const
{
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);

	if (valuePin->LinkedTo.Num() > 0 && valuePin->LinkedTo[0])
		valuePin->PinType = valuePin->LinkedTo[0]->PinType;
	else
	{
		valuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
		valuePin->PinType.PinSubCategory = NAME_None;
		valuePin->PinType.PinSubCategoryObject = nullptr;
		valuePin->PinType.ContainerType = EPinContainerType::None;
		valuePin->PinType.bIsReference = false;
		valuePin->PinType.bIsConst = false;
	}

	if (UEdGraph* graph = GetGraph())
		graph->NotifyGraphChanged();
}

UFunction* UK2Node_GetPropertyByName::GetTargetFunction(const UEdGraphPin* ValuePin)
{
	const UClass* staticsClass = UMounteaInventorySystemStatics::StaticClass();

	if (!ValuePin)
		return nullptr;

	const bool bValidLinks = ValuePin->LinkedTo.Num() > 0;
	if (!bValidLinks)
		return nullptr;

	const FEdGraphPinType& effectiveType = GetEffectiveType(ValuePin);

	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Int)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetIntPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Int64)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetInt64PropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Real)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetFloatPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetBoolPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_String)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetStringPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Name)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetNamePropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Byte)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetBytePropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_SoftObject)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetSoftObjectPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_SoftClass)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetSoftClassPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Class)
		return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, GetClassPropertyValue));
	if (effectiveType.PinCategory == UEdGraphSchema_K2::PC_Struct)
	{
		if (effectiveType.PinSubCategoryObject == TBaseStructure<FVector>::Get())
			return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetVectorPropertyValue));
    
		if (effectiveType.PinSubCategoryObject == TBaseStructure<FVector2D>::Get())
			return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetVector2DPropertyValue));
    
		if (effectiveType.PinSubCategoryObject == TBaseStructure<FGuid>::Get())
			return staticsClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UMounteaInventorySystemStatics, SetGuidPropertyValue));
	}

	return nullptr;
}

void UK2Node_GetPropertyByName::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UEdGraphPin* execPin = GetExecPin();
	UEdGraphPin* thenPin = GetThenPin();
	UEdGraphPin* targetPin = FindPinChecked(TargetPinName);
	UEdGraphPin* propertyNamePin = FindPinChecked(PropertyNamePinName);
	UEdGraphPin* valuePin = FindPinChecked(ValuePinName);
	UEdGraphPin* returnValuePin = FindPinChecked(ReturnValuePinName);

	if (valuePin->LinkedTo.Num() == 0)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("NoValueConsumer", "@@ must have Value pin connected").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UFunction* targetFunction = GetTargetFunction(valuePin);
	if (!targetFunction)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("UnsupportedValueType", "@@ has unsupported value type").ToString(), this);
		BreakAllNodeLinks();
		return;
	}

	UK2Node_CallFunction* callFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	callFunctionNode->SetFromFunction(targetFunction);
	callFunctionNode->AllocateDefaultPins();

	CompilerContext.MovePinLinksToIntermediate(*execPin, *callFunctionNode->GetExecPin());
	CompilerContext.MovePinLinksToIntermediate(*thenPin, *callFunctionNode->GetThenPin());

	UEdGraphPin* functionReturnPin = callFunctionNode->GetReturnValuePin();
	CompilerContext.MovePinLinksToIntermediate(*returnValuePin, *functionReturnPin);

	UEdGraphPin* callTargetPin = callFunctionNode->FindPinChecked(TEXT("Target"));
	CompilerContext.MovePinLinksToIntermediate(*targetPin, *callTargetPin);

	UEdGraphPin* callPropertyNamePin = callFunctionNode->FindPinChecked(TEXT("PropertyName"));
	CompilerContext.MovePinLinksToIntermediate(*propertyNamePin, *callPropertyNamePin);

	UEdGraphPin* callValuePin = callFunctionNode->FindPinChecked(TEXT("Value"));
	CompilerContext.MovePinLinksToIntermediate(*valuePin, *callValuePin);

	BreakAllNodeLinks();
}

void UK2Node_GetPropertyByName::PostReconstructNode()
{
	Super::PostReconstructNode();
	RefreshPinTypes();
}

#if WITH_EDITOR

FText UK2Node_GetPropertyByName::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	FText functionName = LOCTEXT("GetPropertyByName_Title", "Get Property by Name");

	if (TitleType == ENodeTitleType::FullTitle)
	{
		const FText contextString = LOCTEXT("GetPropertyByName_Subtitle", "Source is Advanced Mountea Inventory & Equipment System");

		FFormatNamedArguments namedArgs;
		namedArgs.Add(TEXT("FunctionName"), functionName);
		namedArgs.Add(TEXT("ContextString"), contextString);

		if (contextString.IsEmpty())
			return FText::Format(LOCTEXT("GetPropertyByName_Title_Only", "{FunctionName}"), namedArgs);

		return FText::Format(LOCTEXT("GetPropertyByName_Title_WithContext", "{FunctionName}\n{ContextString}"), namedArgs);
	}

	return functionName;
}

FLinearColor UK2Node_GetPropertyByName::GetNodeTitleColor() const
{
	return FLinearColor(0.0f, 0.55f, 0.62f);
}

FSlateIcon UK2Node_GetPropertyByName::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = FLinearColor(.823f, .823f, .823f);
	return FSlateIcon(FMounteaAdvancedInventoryDeveloperStyle::GetAppStyleSetName(), "MAISStyleSet.K2Node_SetPropertyByName.Small");
}

FText UK2Node_GetPropertyByName::GetTooltipText() const
{
	return LOCTEXT("GetPropertyByName_Tooltip",
		"Gets a property value from a target object by property name using reflection.\n\n"
		"Supported Types:\n"
		"- Int & Int64\n"
		"- Float\n"
		"- Bool\n"
		"- String & Name\n"
		"- Byte\n"
		"- Guid\n"
		"- Vector & Vector2D\n"
		"- Object (with property class validation)\n"
		"- Soft Object (with property class validation)\n"
		"- Class (with property class validation)\n"
		"- Soft Class (with property class validation)\n"
		"\n"
		"Returns false if property doesn't exist or type doesn't match.\n\n"
		"⚠ Please, keep in mind that this will get the value directly! No getter is called! Use with extreme caution!");
}

FText UK2Node_GetPropertyByName::GetVisualWarningTooltipText() const
{
	return LOCTEXT("GetPropertyByName_Warning", 
		"⚠ Please, use with extreme caution!");
}

FText UK2Node_GetPropertyByName::GetToolTipHeading() const
{
	return LOCTEXT("GetPropertyByName_ToolTipHeading", "Mountea Advanced Inventory System");
}

FName UK2Node_GetPropertyByName::GetCornerIcon() const
{
	return TEXT("MAISStyleSet.MounteaLogo");
}

#endif

#undef LOCTEXT_NAMESPACE
